{% comment %}
  Product template - Product Details
{% endcomment %}

<div class="product-page-wrapper" style="position: relative; top: 40px; min-height: calc(100vh - 40px); display: flex; flex-direction: column;">
<div class="breadcrumb-container">
  {% comment %} Automatically link to 'all' collection or first available collection {% endcomment %}
  {% if collections.all %}
    <a href="{{ collections.all.url }}" class="breadcrumb-link">Product List</a>
  {% elsif shop.collections.size > 0 %}
    <a href="{{ shop.collections.first.url }}" class="breadcrumb-link">Product List</a>
  {% else %}
    <a href="{{ routes.collections_url }}" class="breadcrumb-link">Product List</a>
  {% endif %}
  <span class="breadcrumb-arrow">â†’</span>
  <span class="breadcrumb-current">{{ product.title }}</span>
</div>

<div class="product-container">
  {% comment %} Image Section {% endcomment %}
  <div class="image-section" id="imageSection">
      {% for image in product.images %}
        <img 
          src="{{ image | image_url: width: 1200 }}" 
          alt="{{ image.alt | escape }}"
          class="product-image-detail"
          width="{{ image.width }}"
          height="{{ image.height }}"
          loading="lazy"
        >
      {% endfor %}
  </div>

  {% comment %} Product Summary {% endcomment %}
  <div class="product-summary" id="productSummary">
    <div class="title-row">
      <h1 class="product-title">{{ product.title }}</h1>
      <div class="product-price-detail">${{ product.price | money_without_currency }}</div>
    </div>

    {% comment %} Desktop Description {% endcomment %}
    <div class="desktop-description">
      <div class="product-description">
        {% comment %} Render description as HTML - Shopify product descriptions are already HTML {% endcomment %}
        {{ product.description }}
      </div>
    </div>

    <div class="product-options">
      {% comment %} Color - using metafield {% endcomment %}
      {% if product.metafields.custom.color %}
        <div class="product-color">Color: {{ product.metafields.custom.color }}</div>
      {% endif %}

      {% comment %} Size Selection {% endcomment %}
      <div class="sizes-container">
        {% for option in product.options_with_values %}
          {% if option.name == 'Size' or option.name == 'size' or option.name == 'SIZE' %}
            {% for value in option.values %}
              <button 
                type="button" 
                class="size-button" 
                data-size="{{ value }}"
                data-option-index="{{ forloop.parentloop.index0 }}"
                data-value-index="{{ forloop.index0 }}"
              >
                {{ value }}
              </button>
            {% endfor %}
          {% endif %}
        {% endfor %}
      </div>

      {% comment %} Add to Cart Button {% endcomment %}
      <form action="{{ routes.cart_add_url }}" method="post" enctype="multipart/form-data" id="product-form">
        <input type="hidden" name="id" id="selected-variant-id" value="">
        <input type="hidden" name="quantity" value="1">
        <button 
          type="submit" 
          class="add-to-cart-button" 
          id="addToCartButton"
          disabled
        >
          Add to cart
        </button>
        <div id="cart-feedback" class="feedback-message" style="display: none;"></div>
      </form>

      {% comment %} Shipping Info - using metafield {% endcomment %}
      {% if product.metafields.custom.shipping_weeks %}
        <div class="shipping-container">
          This product will ship in {{ product.metafields.custom.shipping_weeks }} weeks
        </div>
      {% else %}
        <div class="shipping-container">
          This product will ship in 4 weeks
        </div>
      {% endif %}
    </div>

    {% comment %} Mobile Description {% endcomment %}
    <div class="mobile-order-wrapper">
      <div class="product-description">
        {% comment %} Render description as HTML - Shopify product descriptions are already HTML {% endcomment %}
        {{ product.description }}
      </div>
    </div>

    {% comment %} Details Dropdowns {% endcomment %}
    <div class="dropdowns-wrapper">
      {% if product.metafields.custom.size_and_fit %}
        {% render 'details-dropdown', title: 'Size + Fit', content: product.metafields.custom.size_and_fit %}
      {% endif %}
      
      {% if product.metafields.custom.care %}
        {% render 'details-dropdown', title: 'Care', content: product.metafields.custom.care %}
      {% endif %}
    </div>
  </div>
</div>
</div>

<div class="product-page-spacer" style="flex: 1; min-height: 100px;"></div>

{{ 'products.css' | asset_url | stylesheet_tag }}

<script>
  const product = {{ product | json }};
  let selectedSize = '';
  let selectedVariantId = '';

  // Initialize size buttons with click handlers
  document.addEventListener('DOMContentLoaded', function() {
    const sizeButtons = document.querySelectorAll('.size-button');
    sizeButtons.forEach(button => {
      button.addEventListener('click', function(e) {
        selectSize(this.dataset.size, this);
      });
    });
    
    // Auto-select first variant if only one variant exists
    if (product.variants.length === 1 && product.variants[0].available) {
      const firstVariant = product.variants[0];
      selectedVariantId = firstVariant.id;
      document.getElementById('selected-variant-id').value = firstVariant.id;
      document.getElementById('addToCartButton').disabled = false;
      
      // Highlight the size button if there's a size option
      if (firstVariant.option1) {
        const matchingButton = Array.from(sizeButtons).find(btn => 
          btn.dataset.size.toLowerCase() === firstVariant.option1.toLowerCase()
        );
        if (matchingButton) {
          matchingButton.classList.add('selected');
        }
      }
    }
  });

  function selectSize(size, buttonElement) {
    selectedSize = size;
    
    // Remove selected class from all buttons
    document.querySelectorAll('.size-button').forEach(btn => {
      btn.classList.remove('selected');
    });
    
    // Add selected class to clicked button
    if (buttonElement) {
      buttonElement.classList.add('selected');
    }
    
    // Find matching variant - check all option positions
    const variant = product.variants.find(v => {
      if (!v.available) return false;
      // Check if any of the variant's options match the selected size
      return v.option1 && v.option1.toLowerCase() === size.toLowerCase() ||
             v.option2 && v.option2.toLowerCase() === size.toLowerCase() ||
             v.option3 && v.option3.toLowerCase() === size.toLowerCase();
    });
    
    if (variant) {
      selectedVariantId = variant.id;
      document.getElementById('selected-variant-id').value = variant.id;
      const addToCartButton = document.getElementById('addToCartButton');
      if (addToCartButton) {
        addToCartButton.disabled = false;
      }
    } else {
      // No variant found - disable add to cart
      const addToCartButton = document.getElementById('addToCartButton');
      if (addToCartButton) {
        addToCartButton.disabled = true;
      }
      showFeedback('This size is not available', 'error');
    }
  }

  // Handle form submission
  document.getElementById('product-form').addEventListener('submit', async function(e) {
    e.preventDefault();
    
    if (!selectedVariantId) {
      showFeedback('Please select a size', 'error');
      return;
    }

    const button = document.getElementById('addToCartButton');
    button.disabled = true;
    button.textContent = 'Adding...';

    try {
      const formData = new FormData(this);
      const response = await fetch('{{ routes.cart_add_url }}', {
        method: 'POST',
        body: formData
      });

      if (response.ok) {
        button.textContent = 'Added to cart';
        showFeedback('Item added to cart', 'success');
        
        // Update cart count in navbar
        updateCartCount();
        
        // Dispatch cart update event
        document.dispatchEvent(new CustomEvent('cart:updated'));
        
        setTimeout(() => {
          button.textContent = 'Add to cart';
          button.disabled = false;
        }, 3500);
      } else {
        throw new Error('Failed to add to cart');
      }
    } catch (error) {
      showFeedback('Failed to add item to cart', 'error');
      button.disabled = false;
      button.textContent = 'Add to cart';
    }
  });

  function showFeedback(message, type) {
    const feedback = document.getElementById('cart-feedback');
    feedback.textContent = message;
    feedback.className = `feedback-message ${type}`;
    feedback.style.display = 'block';
    
    setTimeout(() => {
      feedback.style.display = 'none';
    }, 3000);
  }

  function updateCartCount() {
    fetch('{{ routes.cart_url }}.js')
      .then(response => response.json())
      .then(cart => {
        // Update cart indicators if they exist
        const indicators = document.querySelectorAll('.cart-indicator, .cart-icon-indicator');
        indicators.forEach(indicator => {
          if (cart.item_count > 0) {
            indicator.style.display = 'block';
            indicator.classList.add('pulse');
          } else {
            indicator.style.display = 'none';
          }
        });
      })
      .catch(error => console.error('Error updating cart count:', error));
  }

  // Desktop scroll locking logic - matches React exactly
  function setupScrollLocking() {
    if (window.innerWidth > 768) {
      const imageSection = document.getElementById('imageSection');
      const summarySection = document.getElementById('productSummary');
      
      if (imageSection && summarySection) {
        const handleScroll = () => {
          const imageScrollTop = imageSection.scrollTop;
          const imageScrollHeight = imageSection.scrollHeight - imageSection.clientHeight;
          
          // Lock summary scroll until images are fully scrolled
          if (imageScrollTop < imageScrollHeight) {
            summarySection.scrollTop = 0;
          }
        };
        
        imageSection.addEventListener('scroll', handleScroll, { passive: true });
        
        // Cleanup on resize
        window.addEventListener('resize', function cleanup() {
          if (window.innerWidth <= 768) {
            imageSection.removeEventListener('scroll', handleScroll);
            window.removeEventListener('resize', cleanup);
          }
        });
      }
    }
  }

  // Initialize scroll locking
  setupScrollLocking();

  // Dispatch cart update event
  document.dispatchEvent(new CustomEvent('cart:updated'));
</script>

<style>
  .desktop-description {
    display: block;
  }

  .mobile-order-wrapper {
    display: none;
  }

  @media (max-width: 768px) {
    .desktop-description {
      display: none;
    }

    .mobile-order-wrapper {
      display: block;
      margin-top: 20px;
    }
  }

  .dropdowns-wrapper {
    margin-top: 30px;
  }
</style>

